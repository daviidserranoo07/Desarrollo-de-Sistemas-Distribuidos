/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calc.h"
#include <errno.h>
#include <stdio.h>
#include <stdbool.h>
#include <math.h>
#include <stdlib.h>

int menu(){
	int opcion;
	do{
		printf("\n\nBienvenido a la calculadora porfavor introduzca que operación desea realizar:"
		   		"\n 1.Introduzca 1 para realizar una suma."
				"\n 2.Introduzca 2 para realizar una resta."
				"\n 3.Introduzca 3 para realizar una multiplicación."
				"\n 4.Introduzca 4 para realizar una división."
				"\n 5.Introduzca 5 para sumar componentes de 2 vectores"
				"\n 6.Introduzca 6 para restar componentes de 2 vectores"
				"\n 7.Introduzca 7 para multiplicar componentes de 2 vectores"
				"\n 8.Introduzca 8 para dividir componentes de 2 vectores"
				"\n 9.Introduzca 9 para salir\n");
		scanf("%d",&opcion);
	}while(opcion>9 || opcion<1);
	
	return opcion;
}

void imprimirVectorResultado(double resultado[],int tamanio){
	for(int i=0;i<tamanio;i++){
		printf("\nImprimimos resultado\n");
		printf("El valor del vector resultado en la posicion %d es: %lf",i,resultado[i]);
	}
}


void
calprog_1(char *host, double vector[], int tamanio,int opcion)
{
	CLIENT *clnt;
	calc_res  *result;
	double_vector arg1;

	arg1.size=tamanio;
	for(int i=0;i<tamanio;i++){
		arg1.values[i]=vector[i];
	}


#ifndef	DEBUG
	clnt = clnt_create (host, CALPROG, CAL_VER, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	switch (opcion){
	case 1:
		result = add_1(arg1, clnt);
		if (result == (calc_res *) NULL) {
			clnt_perror (clnt, "call failed");
		}
		printf("\nEl resultado es %lf \n",result->calc_res_u.result);
		break;
	case 2:
		result = substract_1(arg1, clnt);
		if (result == (calc_res *) NULL) {
			clnt_perror (clnt, "call failed");
		}
		printf("\nEl resultado es %lf \n",result->calc_res_u.result);
		break;
	case 3:
		result = multiply_1(arg1, clnt);
		if (result == (calc_res *) NULL) {
			clnt_perror (clnt, "call failed");
		}
		printf("\nEl resultado es %lf \n",result->calc_res_u.result);
		break;
	case 4:
		result = divide_1(arg1, clnt);
		if (result == (calc_res *) NULL) {
			clnt_perror (clnt, "call failed");
		}else if(result->errnum==-1){
			printf("\nNo se puede divdir por 0\n");
		}else{
			printf("\nEl resultado es %lf \n",result->calc_res_u.result);
		}
		break;
	default:
		break;
	}
#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}



void
calvec_1(char *host,double vector1[],double vector2[], int tamanio,int opcion)
{
	CLIENT *clnt;
	calc_vec  *result;
	double_vector vector_arg1;
	double_vector vector_arg2;

	//Copiamos los datos de los vectores pasados como parámetros a la estructura que mandaremos al servidor
	vector_arg1.size=tamanio;
	for(int i=0;i<tamanio;i++){
		vector_arg1.values[i]=vector1[i];
	}

	vector_arg2.size=tamanio;
	for(int i=0;i<tamanio;i++){
		vector_arg2.values[i]=vector2[i];
	}

#ifndef	DEBUG
	clnt = clnt_create (host, CALVEC, CAL_VEC, "udp");
	if (clnt == NULL) {
		clnt_pcreateerror (host);
		exit (1);
	}
#endif	/* DEBUG */

	switch (opcion)
	{
	case 5:
		result = add_vector_1(vector_arg1, vector_arg2, clnt);
		if (result == (calc_vec *) NULL) {
			clnt_perror (clnt, "call failed");
		}
		imprimirVectorResultado(result->calc_vec_u.result.values,result->calc_vec_u.result.size);
		break;
	case 6:
		result = substract_vector_1(vector_arg1, vector_arg2, clnt);
		if (result == (calc_vec *) NULL) {
			clnt_perror (clnt, "call failed");
		}
		imprimirVectorResultado(result->calc_vec_u.result.values,result->calc_vec_u.result.size);
		break;
	case 7:
		result = multiply_vector_1(vector_arg1, vector_arg2, clnt);
		if (result == (calc_vec *) NULL) {
			clnt_perror (clnt, "call failed");
		}
		imprimirVectorResultado(result->calc_vec_u.result.values,result->calc_vec_u.result.size);
		break;
	case 8:
		result = divide_vector_1(vector_arg1, vector_arg2, clnt);
		if (result == (calc_vec *) NULL) {
			clnt_perror (clnt, "call failed");
		}else if(result->errnum==-1){
			printf("\nNo se puede divdir por 0\n");
		}else{
			imprimirVectorResultado(result->calc_vec_u.result.values,result->calc_vec_u.result.size);
		}
		break;
	case 9:
		exit(0);
		break;
	default:
		break;
	}

#ifndef	DEBUG
	clnt_destroy (clnt);
#endif	 /* DEBUG */
}


int
main (int argc, char *argv[])
{
	char *host;
	int opcion=0,cant=0,tipo=0;
	double valor=0.0;

	if (argc < 2) {
		printf ("usage: %s server_host\n", argv[0]);
		exit (1);
	}

	host = argv[1];
	double vector[100],vector1[100],vector2[100];
	do{
		opcion = menu();
		if(opcion!=9){
			if(opcion<5)tipo=1;
			else tipo=2;

			switch (tipo)
			{
			case 1:
				do{
					printf("Cuantos número quiere añadir a la operación: ");
					scanf("%d",&cant);
				}while(cant>100 || cant<0);
				for(int i=0;i<cant;i++){
					printf("Introduzca el siguiente número: ");
					scanf("%lf",&valor);
					vector[i]=valor;
				}
				calprog_1 (host,vector,cant,opcion);
				break;
			case 2:
				do{
					printf("De que tamaño quiere que sean los vectores(ambos tendrán mismo tamaño): ");
					scanf("%d",&cant);
				}while(cant>100 || cant<0);
				for(int i=0;i<cant;i++){
					printf("Introduzca el valor %d del vector 1: ",i);
					scanf("%lf",&valor);
					vector1[i]=valor;
					printf("Introduzca el valor %d del vector 2: ",i);
					scanf("%lf",&valor);
				}
				calvec_1(host,vector1,vector2,cant,opcion);
				break;
			
			default:
				break;
			}
		}
	}while(opcion!=9);
exit (0);
}
